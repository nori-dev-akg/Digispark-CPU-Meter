// Digispark CPU Meter
// Copyright: (c) 2021 by nori-dev-akg
// https://github.com/nori-dev-akg/Digispark-CPU-Meter
// License: MIT

#include "usbdrv.h"

// Digispark Pins

int8_t const data = 1;  // P1
int8_t const cs = 0;    // P0
int8_t const clk = 2;   // P2

#define CSIZE 6 // char width
#define TFT_WIDTH 96
#define TFT_HEIGHT 64

//#define _RASBERRYPI // to use RaspberryPi

enum TextColour { BLACK,RED,GREEN,YELLOW,BLUE,MAGENTA,CYAN,WHITE,OLIVE,ORANGE,YELLOWGREEN };

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
int16_t hidInit(void);  // in hid.c
void drawMeter(uint8_t cpu, uint8_t memory, uint8_t hdd, int16_t net);  // in this file
#ifdef __cplusplus
}
#endif /* __cplusplus */

// Character set for text - stored in program memory
const uint8_t CharMap[][CSIZE] PROGMEM = {
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 
{ 0x00, 0x00, 0x5F, 0x00, 0x00, 0x00 }, 
{ 0x00, 0x07, 0x00, 0x07, 0x00, 0x00 }, 
{ 0x14, 0x7F, 0x14, 0x7F, 0x14, 0x00 }, 
{ 0x24, 0x2A, 0x7F, 0x2A, 0x12, 0x00 }, 
{ 0x23, 0x13, 0x08, 0x64, 0x62, 0x00 }, 
{ 0x36, 0x49, 0x56, 0x20, 0x50, 0x00 }, 
{ 0x00, 0x08, 0x07, 0x03, 0x00, 0x00 }, 
{ 0x00, 0x1C, 0x22, 0x41, 0x00, 0x00 }, 
{ 0x00, 0x41, 0x22, 0x1C, 0x00, 0x00 }, 
{ 0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 0x00 }, 
{ 0x08, 0x08, 0x3E, 0x08, 0x08, 0x00 }, 
{ 0x00, 0x80, 0x70, 0x30, 0x00, 0x00 }, 
{ 0x08, 0x08, 0x08, 0x08, 0x08, 0x00 }, 
{ 0x00, 0x00, 0x60, 0x60, 0x00, 0x00 }, 
{ 0x20, 0x10, 0x08, 0x04, 0x02, 0x00 }, 
{ 0x3E, 0x51, 0x49, 0x45, 0x3E, 0x00 }, 
{ 0x00, 0x42, 0x7F, 0x40, 0x00, 0x00 }, 
{ 0x72, 0x49, 0x49, 0x49, 0x46, 0x00 }, 
{ 0x21, 0x41, 0x49, 0x4D, 0x33, 0x00 }, 
{ 0x18, 0x14, 0x12, 0x7F, 0x10, 0x00 }, 
{ 0x27, 0x45, 0x45, 0x45, 0x39, 0x00 }, 
{ 0x3C, 0x4A, 0x49, 0x49, 0x31, 0x00 }, 
{ 0x41, 0x21, 0x11, 0x09, 0x07, 0x00 }, 
{ 0x36, 0x49, 0x49, 0x49, 0x36, 0x00 }, 
{ 0x46, 0x49, 0x49, 0x29, 0x1E, 0x00 }, 
{ 0x00, 0x00, 0x14, 0x00, 0x00, 0x00 }, 
{ 0x00, 0x40, 0x34, 0x00, 0x00, 0x00 }, 
{ 0x00, 0x08, 0x14, 0x22, 0x41, 0x00 }, 
{ 0x14, 0x14, 0x14, 0x14, 0x14, 0x00 }, 
{ 0x00, 0x41, 0x22, 0x14, 0x08, 0x00 }, 
{ 0x02, 0x01, 0x59, 0x09, 0x06, 0x00 }, 
{ 0x3E, 0x41, 0x5D, 0x59, 0x4E, 0x00 }, 
{ 0x7C, 0x12, 0x11, 0x12, 0x7C, 0x00 }, 
{ 0x7F, 0x49, 0x49, 0x49, 0x36, 0x00 }, 
{ 0x3E, 0x41, 0x41, 0x41, 0x22, 0x00 }, 
{ 0x7F, 0x41, 0x41, 0x41, 0x3E, 0x00 }, 
{ 0x7F, 0x49, 0x49, 0x49, 0x41, 0x00 }, 
{ 0x7F, 0x09, 0x09, 0x09, 0x01, 0x00 }, 
{ 0x3E, 0x41, 0x41, 0x51, 0x73, 0x00 }, 
{ 0x7F, 0x08, 0x08, 0x08, 0x7F, 0x00 }, 
{ 0x00, 0x41, 0x7F, 0x41, 0x00, 0x00 }, 
{ 0x20, 0x40, 0x41, 0x3F, 0x01, 0x00 }, 
{ 0x7F, 0x08, 0x14, 0x22, 0x41, 0x00 }, 
{ 0x7F, 0x40, 0x40, 0x40, 0x40, 0x00 }, 
{ 0x7F, 0x02, 0x1C, 0x02, 0x7F, 0x00 }, 
{ 0x7F, 0x04, 0x08, 0x10, 0x7F, 0x00 }, 
{ 0x3E, 0x41, 0x41, 0x41, 0x3E, 0x00 }, 
{ 0x7F, 0x09, 0x09, 0x09, 0x06, 0x00 }, 
{ 0x3E, 0x41, 0x51, 0x21, 0x5E, 0x00 }, 
{ 0x7F, 0x09, 0x19, 0x29, 0x46, 0x00 }, 
{ 0x26, 0x49, 0x49, 0x49, 0x32, 0x00 }, 
{ 0x03, 0x01, 0x7F, 0x01, 0x03, 0x00 }, 
{ 0x3F, 0x40, 0x40, 0x40, 0x3F, 0x00 }, 
{ 0x1F, 0x20, 0x40, 0x20, 0x1F, 0x00 }, 
{ 0x3F, 0x40, 0x38, 0x40, 0x3F, 0x00 }, 
{ 0x63, 0x14, 0x08, 0x14, 0x63, 0x00 }, 
{ 0x03, 0x04, 0x78, 0x04, 0x03, 0x00 }, 
{ 0x61, 0x59, 0x49, 0x4D, 0x43, 0x00 }, 
{ 0x00, 0x7F, 0x41, 0x41, 0x41, 0x00 }, 
{ 0x02, 0x04, 0x08, 0x10, 0x20, 0x00 }, 
{ 0x00, 0x41, 0x41, 0x41, 0x7F, 0x00 }, 
{ 0x04, 0x02, 0x01, 0x02, 0x04, 0x00 }, 
{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x00 }, 
{ 0x00, 0x03, 0x07, 0x08, 0x00, 0x00 }, 
{ 0x20, 0x54, 0x54, 0x78, 0x40, 0x00 }, 
{ 0x7F, 0x28, 0x44, 0x44, 0x38, 0x00 }, 
{ 0x38, 0x44, 0x44, 0x44, 0x28, 0x00 }, 
{ 0x38, 0x44, 0x44, 0x28, 0x7F, 0x00 }, 
{ 0x38, 0x54, 0x54, 0x54, 0x18, 0x00 }, 
{ 0x00, 0x08, 0x7E, 0x09, 0x02, 0x00 }, 
{ 0x18, 0xA4, 0xA4, 0x9C, 0x78, 0x00 }, 
{ 0x7F, 0x08, 0x04, 0x04, 0x78, 0x00 }, 
{ 0x00, 0x44, 0x7D, 0x40, 0x00, 0x00 }, 
{ 0x20, 0x40, 0x40, 0x3D, 0x00, 0x00 }, 
{ 0x7F, 0x10, 0x28, 0x44, 0x00, 0x00 }, 
{ 0x00, 0x41, 0x7F, 0x40, 0x00, 0x00 }, 
{ 0x7C, 0x04, 0x78, 0x04, 0x78, 0x00 }, 
{ 0x7C, 0x08, 0x04, 0x04, 0x78, 0x00 }, 
{ 0x38, 0x44, 0x44, 0x44, 0x38, 0x00 }, 
{ 0xFC, 0x18, 0x24, 0x24, 0x18, 0x00 }, 
{ 0x18, 0x24, 0x24, 0x18, 0xFC, 0x00 }, 
{ 0x7C, 0x08, 0x04, 0x04, 0x08, 0x00 }, 
{ 0x48, 0x54, 0x54, 0x54, 0x24, 0x00 }, 
{ 0x04, 0x04, 0x3F, 0x44, 0x24, 0x00 }, 
{ 0x3C, 0x40, 0x40, 0x20, 0x7C, 0x00 }, 
{ 0x1C, 0x20, 0x40, 0x20, 0x1C, 0x00 }, 
{ 0x3C, 0x40, 0x30, 0x40, 0x3C, 0x00 }, 
{ 0x44, 0x28, 0x10, 0x28, 0x44, 0x00 }, 
{ 0x4C, 0x90, 0x90, 0x90, 0x7C, 0x00 }, 
{ 0x44, 0x64, 0x54, 0x4C, 0x44, 0x00 }, 
{ 0x00, 0x08, 0x36, 0x41, 0x00, 0x00 }, 
{ 0x00, 0x00, 0x77, 0x00, 0x00, 0x00 }, 
{ 0x00, 0x41, 0x36, 0x08, 0x00, 0x00 }, 
{ 0x02, 0x01, 0x02, 0x04, 0x02, 0x00 }, 
{ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 },
{ 0x03, 0x3b, 0x44, 0x44, 0x28, 0x00 } // degree symbol ℃
};

// OLED 96x64 colour display **********************************************

// Initialisation sequence for OLED module
int16_t const InitLen = 6;
const unsigned char Init[InitLen] PROGMEM = {
  0xA0,       // Driver remap and colour depth
  0x22,       // COM split, flip horizontal
  0xA8, 0x3F, // Multiplex
  0xAD, 0x8E  // External supply
};

// Send a byte to the display
void Send (uint8_t d) {  
  for (uint8_t bit = 0x80; bit; bit >>= 1) {
    PINB = 1<<clk;                        // clk low
    if (d & bit) PORTB = PORTB | (1<<data); else PORTB = PORTB & ~(1<<data);
    PINB = 1<<clk;                        // clk high
  }
}

void InitDisplay () {
  // Define pins
  DDRB = 1<<clk | 1<<cs | 1<<data;  // All outputs
  PORTB = 1<<clk | 1<<cs;           // clk and cs high
  
  PINB = 1<<cs;                           // cs low
  for (uint8_t c=0; c<InitLen; c++) Send(pgm_read_byte(&Init[c]));
  PINB = 1<<cs;                           // cs high
}

// Display off = 0, on = 1
void DisplayOn (uint8_t on) {
  PINB = 1<<cs;                           // cs low
  Send(0xAE + on);
  PINB = 1<<cs;                           // cs high
}

// Graphics **********************************************

void SendFore (int16_t colour) {
  uint8_t ForeR, ForeG, ForeB;
  ForeR=0x3F*(colour&1); ForeG=0x3F*(colour>>1&1)+0x1F*(colour>>3&1); ForeB=0x3F*(colour>>2&1);
  Send(ForeR); Send(ForeG); Send(ForeB);
}

void SendBack (int16_t colour) {
  uint8_t BackR, BackG, BackB;
  BackR=0x3F*(colour&1); BackG=0x3F*(colour>>1&1)+0x1F*(colour>>3&1); BackB=0x3F*(colour>>2&1);
  Send(BackR); Send(BackG); Send(BackB);
}

// Clear display
void ClearDisplay () {
  PINB = 1<<cs;                           // cs low
  Send(0x25);                             // Clear Window
  Send(0); Send(0); Send(95); Send(63);
  PINB = 1<<cs;                           // cs high
  delay(1);
}

// Draw a rectangle in foreground colour optionally filled with background colour
void DrawRect (boolean filled, uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, int16_t foreColor, int16_t backColor) {
  PINB = 1<<cs;                           // cs low
  Send(0x26); Send(filled);               // Enable fill
  Send(0x22);                             // Draw rectangle
  Send(x1); Send(y1); Send(x2); Send(y2);
  SendFore(foreColor);
  SendBack(backColor);
  PINB = 1<<cs;                           // cs high
  delay(1);
}

// Clear a rectangle
void ClearRect (uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2) {
  DrawRect(1, x1, y1, x2, y2, BLACK, BLACK);
}

// Plot character in foreground colour
void PlotChar (uint8_t x, uint8_t y, uint8_t ch, int16_t foreColor, uint8_t scale) {
  PINB = 1<<cs;                           // cs low
  for (uint8_t c = 0 ; c < CSIZE; c++) {      // Column range
    uint8_t bits = pgm_read_byte(&CharMap[ch-32][c]);
    uint8_t r = 0;
    while (bits) {
      while ((bits & 1) == 0) {r++; bits = bits>>1; }
      uint8_t on = (7-r)*scale;
      while ((bits & 1) != 0) {r++; bits = bits>>1; }
      uint8_t off = (7-r)*scale+1;
      for (int16_t i=0; i<scale; i++) {
        uint8_t h = x+c*scale+i;
        Send(0x21);                         // Draw line
        Send(h); Send(y+on); Send(h); Send(y+off);
        SendFore(foreColor);
      }
    }
  }
  PINB = 1<<cs;                             // cs high
}

// Plot text from program memory
void PlotText(PGM_P p, uint8_t x, uint8_t y, int16_t color, uint8_t scale) {
  uint8_t x0 = x;
  char c;
  while(c = pgm_read_byte(p++)) {
    PlotChar(x0, y, c, color, scale);
    x0 += (CSIZE*scale);
  }
}

// Widgets **********************************************
#define MAX_LEN 20  // TILTLE LENGTH MAX
void GetWidgetPos(uint8_t widget, uint8_t* x, uint8_t* y) {
  *x = (widget%2) * (TFT_WIDTH/2);
  *y = 32 - (widget/2) * (TFT_HEIGHT/2);
}

// Draws a titled frame and sets x and y to frame origin
void Frame (uint8_t widget, PGM_P title) {
  uint8_t x, y;
  GetWidgetPos(widget, &x, &y);

  DrawRect(1, x, y, x+(TFT_WIDTH/2) -3, y+(TFT_HEIGHT/2) -5, BLUE, BLACK);

  int8_t len = strnlen_P(title, MAX_LEN);
  
  // centering x
  int8_t xc = ((TFT_WIDTH/2) - len*CSIZE)/2;
  int16_t x1 = x+xc;
  int16_t y1 = y+23;
  ClearRect(x1-1, y1, x1+(len*CSIZE)-1, y1+CSIZE); // clear rect
  PlotText(title, x1, y1, 0x3F, 1);
}

// Plot integer with suffix
void PlotInteger ( uint8_t x, uint8_t y, int16_t number, PGM_P suffix, int16_t color, uint8_t scale) {
  ClearRect(x, y, x+(CSIZE*scale*3), y+(CSIZE*scale)+2); // clear rect
 
  boolean dig = false;

  for(uint8_t j=100, x0=x; j; x0+=(CSIZE*scale)) {
    char c = (abs(number)/j) % 10 + '0';
    if (c == '0' && j != 1 && !dig) c = ' '; else dig = true;;
    PlotChar(x0, y, c, color,scale);
    j=j/10;
  }

  // draw suffix
  uint8_t x1 = x + (CSIZE*scale*3);
  ClearRect(x1, y, x1 + (CSIZE)-1, y + (CSIZE)); // clear rect
  PlotText(suffix, x1, y, WHITE, 1);
}

// Displays an integer with an optional suffix
void IntegerWidget (uint8_t widget, int16_t value, PGM_P suffix, int16_t colour) {
  uint8_t x, y;
  GetWidgetPos(widget, &x, &y);

  PlotInteger(x+3, y+3, value, suffix, colour, 2);
}

// Displays an flag box
void FlagWidget (uint8_t widget, int16_t value, PGM_P suffix, int16_t colour) {
  uint8_t x, y;
  GetWidgetPos(widget, &x, &y);

  uint8_t x0 = x + 3;
  uint8_t y0 = y + 5;

  DrawRect(1, x0, y0, x0 + (TFT_WIDTH/2) - 8, y0 + 14, (value > 0) ? RED:colour, (value > 0) ? RED:BLACK);

  // draw suffix
  PlotText(suffix, x0 + 9, y0 + 4, (value > 0) ? BLACK:colour, 1);
}


#ifdef _RASBERRYPI
void drawFrame() {
  Frame(0, PSTR("CPU"));
  Frame(1, PSTR("Memory"));
  Frame(2, PSTR("Network"));
  Frame(3, PSTR("Temp"));
}

void drawMeter(uint8_t cpu, uint8_t memory, uint8_t temp, int16_t net) {
  PGM_P sfx = PSTR("K");
  if(net<0) { net = net * -1; sfx = PSTR("M"); }
  
  IntegerWidget(0, cpu, PSTR("%"), ORANGE);
  FlagWidget(1, memory, PSTR("swap"), MAGENTA);
  IntegerWidget(2, net, sfx, CYAN);
  IntegerWidget(3, temp, PSTR("\200"), YELLOW);
}

#else
void drawFrame() {
  Frame(0, PSTR("CPU"));
  Frame(1, PSTR("Memory"));
  Frame(2, PSTR("Network"));
  Frame(3, PSTR("HDD"));
}

void drawMeter(uint8_t cpu, uint8_t memory, uint8_t hdd, int16_t net) {
  PGM_P sfx = PSTR("K");
  if(net<0) { net = net * -1; sfx = PSTR("M"); }
  
  IntegerWidget(0, cpu, PSTR("%"), ORANGE);
  IntegerWidget(1, memory, PSTR("%"), MAGENTA);
  IntegerWidget(2, net, sfx, CYAN);
  IntegerWidget(3, hdd, PSTR("%"), YELLOW);
}
#endif

// Setup **********************************************

void setup() {
  hidInit();    // hid.c
  
  InitDisplay();

  ClearDisplay();

  DisplayOn(1);
  
  drawFrame();
}

void loop () {
 
  usbPoll(); // USB ポーリング hid.c
  
}
